# -*- coding: utf-8 -*-
"""
Created on Thu Jul 31 12:44:28 2025

@author: Jake Dunham
"""

import math
import numpy as np
from numpy import sqrt
from numpy import pi, sin, cos
import matplotlib.pyplot as plt
from matplotlib.path import Path
from matplotlib.patches import PathPatch
from matplotlib.patches import Polygon as MplPolygon
from shapely.geometry import Polygon as ShapelyPolygon
from shapely.geometry import MultiPolygon as ShapelyMultiPolygon
from shapely.geometry.collection import GeometryCollection as ShapelyGeometryCollection
from shapely.geometry import LineString as ShapelyLine
from shapely.geometry.polygon import orient
from shapely.geometry import box as ShapelyBox
from shapely.affinity import rotate, translate
from shapely import set_precision
from shapely.ops import unary_union
import gdspy
import time
import ezdxf

def _flatten_polygons(geom_or_iter):
    """
    Yield Shapely Polygons from:
      - Polygon
      - MultiPolygon
      - GeometryCollection (recursively)
      - iterable of any of the above (e.g., list/tuple)
      - None/empty (ignored)
    """
    if geom_or_iter is None:
        return []
    # If it's a plain iterable (list/tuple), flatten each item
    if isinstance(geom_or_iter, (list, tuple)):
        out = []
        for g in geom_or_iter:
            out.extend(_flatten_polygons(g))
        return out

    g = geom_or_iter
    if hasattr(g, "is_empty") and g.is_empty:
        return []

    if isinstance(g, ShapelyPolygon):
        return [g]
    if isinstance(g, ShapelyMultiPolygon):
        return list(g.geoms)
    if isinstance(g, ShapelyGeometryCollection):
        out = []
        for sub in g.geoms:
            out.extend(_flatten_polygons(sub))
        return out

    raise TypeError(f"Unsupported geometry type for flattening: {type(g)}")

def shapely_to_gdspy(shapely_geom, layer=0):
    """
    Convert a Shapely Polygon or MultiPolygon into a flat list of gdspy.Polygon(s).
    Holes are automatically subtracted so the gdspy polygon matches the Shapely polygon.
    """
    gdspy_polys = []

    if shapely_geom.is_empty:
        return gdspy_polys

    if isinstance(shapely_geom, ShapelyPolygon):
        # Exterior ring
        exterior = list(shapely_geom.exterior.coords)[:-1]
        exterior_poly = gdspy.Polygon(exterior, layer=layer)

        # If no holes → just add exterior
        if not shapely_geom.interiors:
            gdspy_polys.append(exterior_poly)
        else:
            # Build list of hole polygons
            hole_polys = [gdspy.Polygon(list(ring.coords)[:-1], layer=layer)
                          for ring in shapely_geom.interiors]

            # Boolean subtraction: exterior - holes
            result = gdspy.boolean(exterior_poly, hole_polys, 'not', layer=layer)
            if result is not None:
                gdspy_polys.append(result)

    elif isinstance(shapely_geom, ShapelyMultiPolygon):
        for poly in shapely_geom.geoms:
            gdspy_polys.extend(shapely_to_gdspy(poly, layer=layer))

    else:
        raise TypeError(f"Unsupported geometry type: {type(shapely_geom)}")

    return gdspy_polys

class VCSELGenerator:
    def __init__(self, 
                 geometry_arrays: list,
                 hole_arrays: list = None,
                 pull_tabs: list = None,
                 lateral_growth: float = None,
                 hole_lateral_growth: float = None,
                 implant_width:float = None,
                 implant_length:float = None,
                 contact_padding = 1,
                 element_zone_padding = 0.2,
                 implant_padding = 1,
                 inv_implant_padding = 1, #optional border added to inverse implant region to make finding mesas under mask easier
                 min_contact_area = 10,
                 contact_width = None):
        """
        Parameters:
            geometry_arrays (list of GeometryArray objects): Each list entry represents a VCSEL mesa structure
            lateral_growth (float): Defines the expected lateral growth of of the mesa structure
        """
        
        #user controlled parameters
        self.geometry_arrays = geometry_arrays
        self.hole_arrays = hole_arrays
        self.pull_tabs = pull_tabs
        self.lateral_growth = lateral_growth
        self.hole_lateral_growth = hole_lateral_growth
        self.implant_width = implant_width
        self.implant_length = implant_length
        self.contact_padding = contact_padding
        self.element_zone_padding = element_zone_padding
        self.implant_padding = implant_padding
        self.inv_implant_padding = inv_implant_padding
        self.min_contact_area = min_contact_area
        self.contact_width = contact_width
        
        #shapely polygon results generated by the methods
        self._exterior_mesa = None
        self._holes = None
        self._mesa = None
        self._aperture = None
        self._contact_region = None
        self._contacts = None
        self._implants = None
    ##########################################################################################
    ### Getters for the generated shapely polygons
    ##########################################################################################
    @property
    def mesa(self):
        "Mesa Vertices getter"
        return[
                list(self._mesa.exterior.coords),
                [list(interior.coords) for interior in self._mesa.interiors]
        ]
    
    @property
    def aperture(self):
        "Aperture Vertices getter"
        return [
                list(self._aperture.exterior.coords),
                [list(interior.coords) for interior in self._aperture.interiors]
               ]
    
    @property
    def contacts(self):
        "Contact Vertices getter"
        return [
                list(self._contacts.exterior.coords),
                [list(interior.coords) for interior in self._contacts.interiors]
               ]
    
    @property
    def implants(self):
        "Implants Vertices getter"
        return [
                list(self._implants.exterior.coords),
                [list(interior.coords) for interior in self._implants.interiors]
            ]
    
    @property
    def bounding_box(self):
        """
        Return (minx, miny, maxx, maxy) covering mesa and implants.
        Works whether implants/mesa are Polygon, MultiPolygon, lists, or collections.
        """
        polys = []
        polys.extend(_flatten_polygons(getattr(self, "_mesa", None)))
        polys.extend(_flatten_polygons(getattr(self, "_implants", None)))

        if not polys:
            raise ValueError("Bounding box requested, but no mesa or implants generated.")

        u = unary_union(polys)
        return u.bounds  # (minx, miny, maxx, maxy)
    
    ###########################################################################################
    ### Generation Methods
    ############################################################################################

    def generate_all(self,inv_fit=True):
        #generate Mesa
        self.generate_mesa()
        #generate aperture
        if self.lateral_growth is not None:
            self.generate_aperture()
        else:
            UserWarning("""VCSELGenerator has no defined Lateral Growth.
                    Unable to generate the aperture.""")
        #generate ion implantation regions
        if self.implant_width is not None and self.implant_length is not None:
            self.generate_implant_regions(fit=inv_fit)
        else:
            UserWarning("""VCSELGenerator has not defined an implant parameters:
                             implant_width or implant_length. Unable to generate
                             the implant regions""")
        #generate metal contacts
        if self._aperture is not None:
            self.generate_contact_partitions(self.contact_padding,
                                                 self.element_zone_padding)
        else:
            UserWarning("""VCSELGenerator failed to generate aperture 
                             or implantation regions. It is unable to generate
                             the contact regions.""")
        
    def generate_mesa(self):
        """
        Unions all elements from all GeometryArrays into a single mesa shape (Shapely).
        """
        all_mesas = []
        for g_array in self.geometry_arrays:
            all_mesas.extend(g_array.to_shapely())
        
        mesa_wo_holes = unary_union(all_mesas)
        self._exterior_mesa = mesa_wo_holes

        if self.hole_arrays:
            all_holes = []
            for h_array in self.hole_arrays:
                all_holes.extend(h_array.to_shapely())
            holes_union = unary_union(all_holes)
            self._holes = holes_union

            self._mesa = mesa_wo_holes.difference(holes_union)
        else:
            self._mesa = mesa_wo_holes

    def generate_aperture(self, lateral_growth = None):
        """
        Buffers the mesa inward to create the aperture.
        
        Parameters:
            offset (float): Value for shrinking the mesa.
        
        Returns:
            shapely.geometry.Polygon or MultiPolygon
        """
        #both are none
        if lateral_growth is None and self.lateral_growth is None:
            raise ValueError('DeviceGenerator requires a lateral_growth to generate the aperture.')
        #both are something
        elif lateral_growth is not None and self.lateral_growth is not None:
            UserWarning(f"""Overwriting DeviceGenerator's lateral growth from
                        {self.lateral_growth=} to {lateral_growth}""")
        #one of them is something
        elif self.lateral_growth is None:
            #the object attribute is missing
            self.lateral_growth = lateral_growth
        
        if self.lateral_growth < 0:
            UserWarning("""lateral_growth cannot physically be negative. 
                        Growth is negative relative to the boundary.
                        Handled your input under this assumption.""")
        else:
            self.lateral_growth = -self.lateral_growth
        
        if self._mesa is None:
            self.generate_mesa()

        self._aperture = self._exterior_mesa.buffer(self.lateral_growth,resolution=100)

        # applies secondary lateral growth to holes if specified
        if self._holes:
            if self.hole_lateral_growth is None:
                UserWarning("""VCSELGenerator has holes defined but no hole_lateral_growth. Using lateral_growth.""")
                self.hole_lateral_growth = self.lateral_growth

            if self.hole_lateral_growth < 0:
                UserWarning("""Only positive growth of holes is allowed.""")
                self.hole_lateral_growth = -self.hole_lateral_growth
            
            grown_holes = self._holes.buffer(self.hole_lateral_growth,resolution=100)
            self._aperture = self._aperture.difference(grown_holes)
    
    def generate_implant_regions(self,implant_width = None, implant_length = None, fit=True):
        """
        Generate rectangular ion implant blockers between nearest neighboring centers
        across all GeometryArrays in self.geometry_arrays.
        Handles ties for equidistant neighbors.
        """
        # Check implant_width
        if implant_width is None:
            if hasattr(self, "implant_width") and self.implant_width is not None:
                implant_width = self.implant_width
            else:
                raise ValueError("implant_width must be provided or stored in self.implant_width")
        # Check implant_length
        if implant_length is None:
            if hasattr(self, "implant_length") and self.implant_length is not None:
                implant_length = self.implant_length
            else:
                raise ValueError("implant_length must be provided or stored in self.implant_length")
        # Store for later calls
        self.implant_width = implant_width
        self.implant_length = implant_length        
        # Collect all centers from all geometry arrays
        centers = []
        for geometry_array in self.geometry_arrays:
            centers.extend([tuple(element.center) for element in geometry_array.elements])
        # create implant region geomerties
        implantations = [] 
        start_time = time.time()
        for i, c1 in enumerate(centers):
            # Compute distances to all other centers
            distances = []
            for j, c2 in enumerate(centers):
                if i != j:
                    dist = np.hypot(c2[0] - c1[0], c2[1] - c1[1])
                    distances.append((dist, c2))
                if not distances:
                    continue
            # Find the minimum non-zero distance
            min_dist = min(d[0] for d in distances)
            # Get all centers at that exact minimum distance (handle ties)
            nearest_centers = [c2 for dist, c2 in distances if np.isclose(dist, min_dist)]
            # Create region at midpoint of each nearest neighbor
            for c2 in nearest_centers:
                midpoint = ((c1[0] + c2[0]) / 2, (c1[1] + c2[1]) / 2)
                dx, dy = c2[0] - c1[0], c2[1] - c1[1]
                angle_deg = np.degrees(np.arctan2(dy, dx))
                # Rectangle centered at origin
                rect = ShapelyBox(-implant_length / 2, -implant_width / 2,
                                  implant_length / 2, implant_width / 2)
                # Rotate and move to midpoint
                rotated = rotate(rect, angle_deg, origin=(0, 0), use_radians=False)
                placed = translate(rotated, xoff=midpoint[0], yoff=midpoint[1])
                implantations.append(placed)
        end_time = time.time()
        print(f"Implant regions generated in {(end_time-start_time):.3f} seconds")
        # Merge implant regions into a single geometry
        implant_union = unary_union(implantations)
        self._implants = implant_union
        self._implants_inv = self._invert_implantation(implant_union,fit)
    
    def _invert_implantation(self,implants,fit=True):
        start_time = time.time()
        if fit:
            unexposed_region = self._mesa.difference(implants)
        else:
            bboxs = []
            for GA in self.geometry_arrays:
                minx,miny,maxx,maxy = np.array(GA.get_bounding_box()) + np.array((-1,-1,1,1))*self.inv_implant_padding
                bboxs.append(ShapelyBox(minx,miny,maxx,maxy))
            unexposed_region = unary_union(bboxs).difference(implants)
            unexposed_region = self._filter_small_polygons(unexposed_region, 5)
        end_time = time.time()
        print(f"Implant region inversion generated in {(end_time-start_time):.3f} seconds")
        return unexposed_region
        

    def _generate_contact_region(self, contact_padding, implant_padding = 0):
        """
        Generate a contact ring between the mesa and aperture using the specified padding.
        This region represents where metal contact is allowed.
        """
        if self._mesa is None:
            self.generate_mesa()
        if self._aperture is None:
            raise ValueError("Aperture must be generated before creating contact region.")

        # Shrink mesa inward, grow aperture outward
        outer = self._mesa.buffer(-contact_padding)
        
        if self.contact_width:
            inner = self._mesa.buffer(-self.contact_width-contact_padding)
        else:
            inner = self._aperture.buffer(contact_padding)
        
        # Clean, orient, and set precision of geometries
        # outer = outer.buffer(0)
        # inner = inner.buffer(0)
        
        # outer = orient(outer, sign=1.0)
        # inner = orient(inner, sign=1.0)
        
        # outer = set_precision(outer, grid_size=1e-6)
        # inner = set_precision(inner, grid_size=1e-6)

        # inner = inner.buffer(-1e-9)
    
        pre_implant_contact_region = outer.difference(inner)
        if self._implants is not None:
            self._contact_region = pre_implant_contact_region.difference(self._implants.buffer(implant_padding))
        else:
            self._contact_region = pre_implant_contact_region
            
        if self.pull_tabs:
            all_tabs = []
            for tab in self.pull_tabs:
                all_tabs.extend(tab.to_shapely())
            tab_union = unary_union(all_tabs)
            self._contact_region = self._contact_region.difference(tab_union)

        if self._contact_region.is_empty or not self._contact_region.is_valid:
            raise ValueError("Generated contact region is empty or invalid. Check padding.")
    
    def generate_contact_partitions(self, contact_padding = None,
                                    element_zone_padding = None,
                                    implant_padding = None,
                                    min_contact_area = None):
        """
        Generate and store non-overlapping contact partitions using XOR logic.

        Parameters:
            contact_padding (float): Clearance between metal and mesa/aperture boundaries.
            per_element_padding (float): Radius around each element where metal can be placed.

        Stores:
            self._contacts: List of Shapely Polygon/MultiPolygon objects.
        Returns:
            List of contact partitions.
        """
        start_time = time.time()
        #input checks
        # Check contact_padding
        if contact_padding is None:
            if hasattr(self, "contact_padding") and self.contact_padding is not None:
                contact_padding = self.contact_padding
            else:
                raise ValueError("contact_padding must be provided or stored in self.contact_padding")
        # Check element_zone_padding
        if element_zone_padding is None:
            if hasattr(self, "element_zone_padding") and self.element_zone_padding is not None:
                element_zone_padding = self.element_zone_padding
            else:
                raise ValueError("element_zone_padding must be provided or stored in self.element_zone_padding")              
        # Check implant_padding
        if implant_padding is None:
            if hasattr(self, "implant_padding") and self.implant_padding is not None:
                implant_padding = self.implant_padding
            else:
                raise ValueError("implant_padding must be provided or stored in self.implant_padding")
        # Check min_contact_area
        if min_contact_area is None:
            if hasattr(self, "min_contact_area") and self.min_contact_area is not None:
                min_contact_area = self.min_contact_area
            else:
                raise ValueError("min_contact_area must be provided or stored in self.min_contact_area")
        # Store for later calls
        self.contact_padding = contact_padding
        self.element_zone_padding = element_zone_padding
        self.implant_padding = implant_padding
        self.min_contact_area = min_contact_area
        
        self._generate_contact_region(contact_padding,implant_padding)
        partitions = []
        for geometry_array in self.geometry_arrays:
            for element in geometry_array.elements:
                # Convert custom polygon to Shapely polygon using vertices
                shapely_poly = ShapelyPolygon(element.get_transformed_vertices())
                
                # Buffer element polygon for per-element padding
                padded_elem = shapely_poly.buffer(element_zone_padding)

                # Remove implant blockers area from the padded element area if implant exists
                if self._implants:
                    implants_padded = self._implants.buffer(implant_padding)
                    effective_elem = padded_elem.difference(implants_padded)
                else:
                    effective_elem = padded_elem

                # Intersection with contact region
                partition = self._contact_region.intersection(effective_elem)
                
                #filter out partition polygons that are below the minimum acceptable area
                cleaned_partition = self._filter_small_polygons(partition, self.min_contact_area)
                
                if cleaned_partition is not None:
                    partitions.append(cleaned_partition)

        self._contacts = unary_union(partitions)
        end_time = time.time()
        print(f'Contacts generated in {(end_time-start_time):.3f} seconds')
    
    ################################################################################
    ### Plotting Methods
    ################################################################################

    def plot(self, show_mesa=True,
         show_aperture=True,
         show_implant=True,
         show_implant_inv=False,
         show_contact_partitions=True,
         show_contact_region=False,
         ax=None, **kwargs):
        """
        Plots mesa, aperture, contact region ring, contact partitions, and implant blockers on a matplotlib axis.

        Parameters:
            show_mesa (bool): Plot mesa polygon.
            show_aperture (bool): Plot aperture polygon.
            show_contact_region (bool): Plot the contact ring (global contact region).
            show_contact_partitions (bool): Plot the per-element contact partitions.
            show_implant (bool): Plot the implant blocker regions.
            ax (matplotlib.axes.Axes): Optional matplotlib axis to plot on.
            **kwargs: Additional plotting keyword args (passed to _plot_shape).
        """
        start_time = time.time()
        if ax is None:
            fig, ax = plt.subplots()

        if show_mesa:
            if self._mesa is None:
                raise ValueError("Mesa not generated yet. Run generate_mesa() first.")
            self._plot_shape(self._mesa, ax, facecolor='gray', alpha=0.5, label="Mesa", **kwargs)

        if show_aperture:
            if self._aperture is None:
                raise ValueError("Aperture not generated yet. Run generate_aperture() first.")
            self._plot_shape(self._aperture, ax, facecolor='blue', alpha=0.4, label="Aperture", **kwargs)

        if show_contact_region:
            if self._contact_region is None:
                raise ValueError("Contact region not generated yet. Run _generate_contact_region() first.")
            self._plot_shape(self._contact_region, ax, facecolor='orange', alpha=0.3, label="Contact Region", **kwargs)

        if show_contact_partitions:
           if not hasattr(self, '_contacts') or self._contacts is None:
               raise ValueError("Contact partitions not generated yet. Run generate_contact_partitions_xor() first.")

           color = kwargs.get('color', None) or 'green'
           alpha = kwargs.get('alpha', 0.5)
           label = "Contacts"

           # _plot_shape handles Polygon and MultiPolygon
           self._plot_shape(self._contacts, ax, facecolor=color, alpha=alpha, label=label)

        if show_implant:
            if not hasattr(self, '_implants') or self._implants is None:
                raise ValueError("Implantation not generated yet. Run generate_implant_regions() first.")
            color = kwargs.get('color', None) or 'purple'
            alpha = kwargs.get('alpha', 0.4)
            label = "Implant"
            if isinstance(self._implants, ShapelyPolygon):
                self._plot_shape(self._implants, ax, facecolor=color, alpha=alpha, label=label)
            elif isinstance(self._implants, ShapelyMultiPolygon):
                for i, poly in enumerate(self._implants.geoms):
                    self._plot_shape(poly, ax, facecolor=color, alpha=alpha, label=label if i == 0 else None)
            else:
                raise ValueError(f"Unsupported geometry type for _implants: {type(self._implants)}")

        if show_implant_inv:
            if not hasattr(self, '_implants_inv') or self._implants_inv is None:
                raise ValueError("Implant not generated yet. Run generate_implant_regions() first.")
            color = kwargs.get('color', None) or 'purple'
            alpha = kwargs.get('alpha', 0.4)
            label = "Inverse Implant"
            if isinstance(self._implants_inv, ShapelyPolygon):
                self._plot_shape(self._implants_inv, ax, facecolor=color, alpha=alpha, label=label)
            elif isinstance(self._implants_inv, ShapelyMultiPolygon):
                for i, poly in enumerate(self._implants_inv.geoms):
                    self._plot_shape(poly, ax, facecolor=color, alpha=alpha, label=label if i == 0 else None)
            else:
                raise ValueError(f"Unsupported geometry type for _implants: {type(self._implants)}")
    
        ax.set_aspect('equal')
        ax.legend(loc='upper right')
        end_time = time.time()
        print(f'Plotted polygons in {(end_time-start_time):.3f} seconds')

    def _plot_shape(self, shape, ax, facecolor='gray', edgecolor='black', alpha=1.0, label=None, **kwargs):
        """
        Plot a Shapely Polygon or MultiPolygon with holes correctly shown as transparent.
        """
        if ax is None:
            fig, ax = plt.subplots()
           
        def plot_poly(poly,label=None):
            path =  self._polygon_with_holes_to_path(poly)
            patch = PathPatch(path, facecolor=facecolor, edgecolor=edgecolor, alpha=alpha, label=label, **kwargs)
            ax.add_patch(patch)

        if isinstance(shape, ShapelyPolygon):
            plot_poly(shape,label)
        elif isinstance(shape, ShapelyMultiPolygon):
            first = True
            for poly in shape.geoms:
                plot_poly(poly, label if first else None)
                first = False
                
        else:
            raise TypeError(f"Unsupported geometry type: {type(shape)}")
           
        ax.autoscale_view()
        ax.set_aspect('equal')
                
    def to_gdspy(self,include_aperture=False,contact_layer = None, mesa_layer = None, ion_layer = None):
        if contact_layer is None:
            contact_layer = 1
        if mesa_layer is None:
            mesa_layer = 2
        if ion_layer is None:
            ion_layer = 3
        polygons = []
        #layers ordered vertically from substrate (layer 0)
        if hasattr(self,"_mesa"):
            polygons.append(shapely_to_gdspy(self._mesa,layer=mesa_layer))
        
        if hasattr(self,"_contacts") and self._contacts:
            polygons.append(shapely_to_gdspy(self._contacts,layer=contact_layer))
        
        if hasattr(self,"_implants_inv") and self._implants_inv:
            polygons.append(shapely_to_gdspy(self._implants_inv,layer=ion_layer))

        if include_aperture and hasattr(self,"_aperture"):
            polygons.append(shapely_to_gdspy(self._aperture,layer=99))
            
        return polygons
    
    def write_dxf(
            self,
            outfile: str,
            include_aperture: bool = False,
            layer_map: dict | None = None,
            insunits: int | None = None,
            lwpolyline: bool = True,
            ) -> str:
        """
        Write VCSEL layers to a DXF file.

        Layers written
        --------------
        - Mesa (self._mesa)
        - Contacts (self._contacts)
        - Implants (inverse) (self._implants_inv)
        - Aperture (self._aperture) [optional, include_aperture=True]

        Parameters
        ----------
        outfile : str
            Path to the DXF to create.
        include_aperture : bool
            If True, also writes the aperture geometry on its own layer.
        layer_map : dict | None
            Mapping of logical names to DXF layer names, e.g.:
                {"mesa":"MESA","contacts":"CONTACTS","implants":"IMPLANTS","aperture":"APERTURE"}.
                Defaults to those names if not provided.
        insunits : int | None
            DXF $INSUNITS header (0=unitless, 1=inches, 4=mm, 6=meters, etc.).
        lwpolyline : bool
            If True, write LWPOLYLINE; otherwise, POLYLINE (2D).

        Returns
        -------
        str
            The written file path.
        """
        if ezdxf is None:
            raise ImportError("ezdxf is required for write_dxf(). Install with `pip install ezdxf`.")

        # Default layer names consistent with to_gdspy ordering
        # (contacts, mesa, implants_inv, optional aperture)
        default_layers = {
            "contacts": "CONTACTS",
            "mesa": "MESA",
            "implants": "IMPLANTS",
            "aperture": "APERTURE",
        }
        if layer_map:
            default_layers.update(layer_map)
        L = default_layers  # alias

        # Create DXF document & modelspace
        doc = ezdxf.new("R2010")
        msp = doc.modelspace()
        if insunits is not None:
            doc.header["$INSUNITS"] = int(insunits)

        # Ensure layers exist
        for name in {L["contacts"], L["mesa"], L["implants"], L["aperture"]}:
            if name not in doc.layers:
                doc.layers.new(name=name)

        def _ring_to_seq(ring):
            # DXF closed polylines don't need the last point repeated
            # Keep as float tuples
            coords = list(ring.coords)
            if len(coords) >= 2 and (coords[0][0] == coords[-1][0] and coords[0][1] == coords[-1][1]):
                coords = coords[:-1]
            return [(float(x), float(y)) for x, y in coords]

        def _emit_polygon(poly, layer_name):
            # exterior
            ext = _ring_to_seq(poly.exterior)
            if lwpolyline:
                msp.add_lwpolyline(ext, format="xy", dxfattribs={"layer": layer_name, "closed": True})
            else:
                pl = msp.add_polyline2d(ext, dxfattribs={"layer": layer_name})
                pl.close(True)
            # holes as their own closed polylines (many importers treat these as holes or separate loops)
            for hole in poly.interiors:
                inn = _ring_to_seq(hole)
                if lwpolyline:
                    msp.add_lwpolyline(inn, format="xy", dxfattribs={"layer": layer_name, "closed": True})
                else:
                    pl = msp.add_polyline2d(inn, dxfattribs={"layer": layer_name})
                    pl.close(True)

        def _emit_geometry(geom, layer_name):
            if geom is None:
                return
            # Supports Polygon and MultiPolygon (your generator stores these) 
            # and collections via your existing pipeline.
            from shapely.geometry import Polygon as _Poly
            from shapely.geometry import MultiPolygon as _MP
            from shapely.geometry.collection import GeometryCollection as _GC

            if isinstance(geom, _Poly):
                _emit_polygon(geom, layer_name)
            elif isinstance(geom, _MP):
                for g in geom.geoms:
                    _emit_polygon(g, layer_name)
            elif isinstance(geom, _GC):
                for g in geom.geoms:
                    _emit_geometry(g, layer_name)
            else:
                # try to iterate (e.g., list of polygons)
                try:
                    for g in geom:
                        _emit_geometry(g, layer_name)
                except TypeError:
                    pass  # silently skip unsupported types

        # Write layers in same spirit as to_gdspy()
        if hasattr(self, "_mesa") and self._mesa is not None:
            _emit_geometry(self._mesa, L["mesa"])
        if hasattr(self, "_contacts") and self._contacts is not None:
            _emit_geometry(self._contacts, L["contacts"])
        if hasattr(self, "_implants_inv") and self._implants_inv is not None:
            _emit_geometry(self._implants_inv, L["implants"])
        if include_aperture and hasattr(self, "_aperture") and self._aperture is not None:
            _emit_geometry(self._aperture, L["aperture"])

        doc.saveas(outfile)
    
    @staticmethod 
    def _polygon_with_holes_to_path(polygon):
        """
        Convert a Shapely Polygon (with optional holes) into a valid Matplotlib Path.
        Ensures proper code/vertex pairing for exterior and interior rings.
        """
        def ring_to_path(ring):
            coords = np.asarray(ring.coords)
            vertices = np.concatenate([coords, [coords[0]]])  # Ensure closed
            codes = [Path.MOVETO] + [Path.LINETO] * (len(coords) - 1) + [Path.CLOSEPOLY]
            return vertices, codes

        vertices_list = []
        codes_list = []

        # Exterior
        verts, codes = ring_to_path(polygon.exterior)
        vertices_list.append(verts)
        codes_list.append(codes)

        # Interiors (holes)
        for interior in polygon.interiors:
            verts, codes = ring_to_path(interior)
            vertices_list.append(verts)
            codes_list.append(codes)

        # Combine
        all_vertices = np.vstack(vertices_list)
        all_codes = sum(codes_list, [])
        
        return Path(all_vertices, all_codes)
    
    @staticmethod
    def _filter_small_polygons(geometry, min_area):
        """
        Remove polygon parts smaller than min_area.
        Handles Polygon, MultiPolygon, and GeometryCollection.
        Returns a Polygon, MultiPolygon, or None.
        """
        if isinstance(geometry, ShapelyPolygon):
            return geometry if geometry.area >= min_area else None

        elif isinstance(geometry, ShapelyMultiPolygon):
            filtered = [poly for poly in geometry.geoms if poly.area >= min_area]
            if not filtered:
                return None
            elif len(filtered) == 1:
                return filtered[0]
            else:
                return unary_union(filtered)

        elif isinstance(geometry, ShapelyGeometryCollection):
            # Extract polygons from GeometryCollection and filter them
            polygons = [geom for geom in geometry.geoms if isinstance(geom, ShapelyPolygon)]
            filtered = [poly for poly in polygons if poly.area >= min_area]
            if not filtered:
                return None
            elif len(filtered) == 1:
                return filtered[0]
            else:
                return unary_union(filtered)

        else:
            # Unsupported geometry type
            return None
    
    @staticmethod
    def _extract_polygons(geom):
        """Return a list of Polygon objects from a Polygon or MultiPolygon."""
        if geom.is_empty:
            return []
        if isinstance(geom, ShapelyPolygon):
            return [geom]
        elif isinstance(geom, ShapelyMultiPolygon):
            return list(geom.geoms)
        else:
            # sometimes shapely returns GeometryCollection
            return [g for g in geom.geoms if isinstance(g, ShapelyPolygon)]
        
#%%
class GeometryArray:
    def __init__(self, elements=None):
        self.elements = elements or []  # list of ArrayElement instances

    def add_element(self, element):
        self.elements.append(element)

    def plot(self, ax=None, **kwargs):
        fig, ax = plt.subplots()

        for element in self.elements:
            element.plot(ax=ax)  # Reuse shared axis

        plt.title("Full Geometry Array")
        plt.show()
    
    def center_array(self):
        raise NotImplementedError

    def to_gdspy(self, layer=0):
        gdspy_polygons = []
        for element in self.elements:
            verts = element.get_transformed_vertices()
            gdspy_polygons.append(gdspy.Polygon(verts, layer=layer))
        return gdspy_polygons

    def to_shapely(self):
        shapely_polygons = []
        for element in self.elements:
            verts = element.get_transformed_vertices()
            shapely_polygons.append(ShapelyPolygon(verts))
        return shapely_polygons
    
    # --- NEW: bounding box helpers ---
    def get_bounding_box(self, method: str = "vertices"):
        """
        Return (minx, miny, maxx, maxy) covering all elements.

        Parameters
        ----------
        method : {'vertices', 'union'}
            'vertices' (default): fast; uses raw element vertices.
            'union'            : robust; unions Shapely polygons (fixes minor self-intersections).

        Raises
        ------
        ValueError
            If the array is empty or contains no valid geometry.
        """
        if not self.elements:
            raise ValueError("GeometryArray is empty; cannot compute a bounding box.")

        if method == "vertices":
            xs, ys = [], []
            for el in self.elements:
                v = np.asarray(el.get_transformed_vertices(), dtype=float)
                if v.size == 0:
                    continue
                # Expect shape (N,2)
                xs.append(v[:, 0])
                ys.append(v[:, 1])
            if not xs:  # all elements empty/degenerate
                raise ValueError("No element has vertices; cannot compute a bounding box.")
            xs = np.concatenate(xs); ys = np.concatenate(ys)
            return (float(np.min(xs)), float(np.min(ys)),
                    float(np.max(xs)), float(np.max(ys)))

        if method == "union":
            polys = []
            for el in self.elements:
                verts = el.get_transformed_vertices()
                if verts is None or len(verts) < 3:
                    continue
                p = ShapelyPolygon(verts)
                # Fix minor self-intersections if needed
                if not p.is_valid:
                    p = p.buffer(0)
                if not p.is_empty:
                    polys.append(p)
            if not polys:
                raise ValueError("No valid polygons to union; cannot compute a bounding box.")
            u = unary_union(polys)
            return u.bounds  # (minx, miny, maxx, maxy)

        raise ValueError(f"Unknown method '{method}'. Use 'vertices' or 'union'.")
        
#%% ArrayElement Class
#array elements hold information on the center, and rotation of a BasePolgyon 
class ArrayElement:
    def __init__(self, polygon, center=(0, 0), rotation_deg=0):
       """
       Initialize an ArrayElement with a polygon, center point, and rotation angle.
       
       Parameters:
           polygon (BasePolygon): The polygon object (must have .vertices).
           center (tuple): (x, y) position to place the polygon's center.
           rotation_deg (float): Rotation angle in degrees around the center.
       """
       self.polygon = polygon
       self.center = np.array(center)
       self.rotation_deg = rotation_deg

    def get_transformed_vertices(self):
       """
       Return the polygon vertices rotated around the origin and translated to the center.
       """
       vertices = np.array(self.polygon.vertices)

       # Step 2: Rotate about origin
       theta = np.deg2rad(self.rotation_deg)
       rotation_matrix = np.array([
           [np.cos(theta), -np.sin(theta)],
           [np.sin(theta),  np.cos(theta)]
       ])
       
       rotated = vertices @ rotation_matrix.T #matrix multiplication

       # Step 3: Translate to specified center
       final_vertices = rotated + self.center
       return final_vertices.tolist()
   
    def resize(self,offset):
        """
        Erodes or dilates the polygon. 
        Does not modify the rotation or translation!
       
       Parameters:
       - offset: float
           Positive value for dilation, negative for erosion.

        """
        # 1. Get polygon vertices in global coordinates
        vertices = self.polygon.vertices
        shapely_poly = ShapelyPolygon(vertices)

        # 2. Erode/dilate using Shapely's buffer
        resized_poly = shapely_poly.buffer(offset)

        if resized_poly.is_empty or not resized_poly.is_valid:
           raise ValueError("Resizing resulted in an invalid or empty polygon.")

        # 3. Convert result to list of (x, y) vertices
        new_vertices = list(resized_poly.exterior.coords)

        # 4. Remove closing vertex (last point == first point)
        if np.allclose(new_vertices[0], new_vertices[-1]):
            new_vertices = new_vertices[:-1]

        # 5. Replace self.polygon with new BasePolygon
        self.polygon = BasePolygon(vertices = new_vertices, t = 'BasePolygon')
        return self
    
    def plot(self, ax=None, **kwargs):
        transformed = self.get_transformed_vertices()
        plot_polygon(transformed, title=f"{self.polygon.t} Element", ax=ax, **kwargs)
        
    def copy_with_transform(self, center=None, rotation_deg=None):
        """
        Returns a new ArrayElement with the same polygon,
        but a new center and/or rotation.
        """
        new_center = center if center is not None else self.center
        new_rotation = rotation_deg if rotation_deg is not None else self.rotation_deg
        return ArrayElement(self.polygon, new_center, new_rotation)

#%% Geometry Classes
#geometry classes check for proper definition of a polygon in terms of its
#vertices. Also computes the side lengths and internal angles if useful
class BasePolygon:
    def __init__(self, vertices, t = 'BasePolygon'):
        if vertices is None or len(vertices) < 3:
            raise ValueError("Polygon must have at least 3 vertices.")
        
        self.vertices = vertices    
        
        self.side_lengths, self.angles_deg = polygon_from_vertices(vertices)
        
        if all_sides_equal(self.side_lengths):
            self.t = 'Regular ' + t
        else:
            self.t = 'Irregular ' + t 
    
        
    def plot(self, ax=None, **kwargs):
        plot_polygon(self.vertices, title=self.t, ax=ax, **kwargs)

class Circle(BasePolygon):
    def __init__(self, vertices):
        #currently no additional checks being handled by Circle init
        super().__init__(vertices,'Circle')
    
    @classmethod
    def from_radius(cls, r, vertex_count = 100):
        if r == 0:
            raise ValueError("""Input not excepted. Produces a polygon of 1 distinct vertex.
                             """)
        theta = np.linspace(0, 2*np.pi, vertex_count, endpoint=False)
        x = r * np.cos(theta)
        y = r * np.sin(theta)
        vertices = list(zip(x,y))
        return cls(vertices)
    
    @classmethod
    def quarter_circle(cls, radius, thickness, offset, resolution = 128):
        #create quarter circle arc
        
        angles = np.linspace(offset, np.pi/2-offset, resolution)
        coords = [(radius*np.cos(a),radius*np.sin(a)) for a in angles]
        arc = ShapelyLine(coords)
        
        #buffer the arc to give it area
        thicc_arc = arc.buffer(thickness)
        vertices = list(thicc_arc.exterior.coords)
        return cls(vertices)
        
    
class Hexagon(BasePolygon):
    #use the class methods which wrap init in simpler parameters for ease of use
    def __init__(self, vertices):
        
        #checks that vertices meets the min requirements of a hexagon
        if len(vertices) != 6:
            raise ValueError("Hexagon must exactly 6 vertices.")
            
        #assign vertices, type of polygon, and computes side_lengths, and internal angles of polygon
        super().__init__(vertices, 'Hexagon')

    @classmethod
    def from_dimensions(cls,
                        width = [1, 1],
                        height = [sqrt(3)/2, sqrt(3)/2],
                        side_length = [1,1]):
        """
        Creates a flat-topped hexagon from width, height, and side_length

        """
        w1 = width[0]
        w2 = width[1]
        h1 = height[0]
        h2 = height[1]
        sl = side_length[0] / 2
        s2 = side_length[1] / 2
        
        vertices = [
                (-sl,-h1),
                (sl,-h1),
                (w2,0),
                (s2,h2),
                (-s2,h2),
                (-w1,0)
            ]
        
        #calls __init__() with the wrapped vertices
        return cls(vertices)

    @classmethod
    def from_inradii(cls,inradii):
        """
        Construct a convex hexagon from given inradii (distances from incenter to each side).
        Assumes equiangular hexagon (sides are separated by 60°).
        
        Parameters:
            inradii (list of float): six inradii.
            """
        if len(inradii) != 6:
            raise ValueError("Need exactly 6 inradii for a hexagon.")

        n_sides = 6
        angle_step = 2 * math.pi / n_sides

        # Compute outward normals
        normals = [(math.cos(i * angle_step),
                    math.sin(i * angle_step)) for i in range(n_sides)]

        # Each side line in form: a*x + b*y = c
        lines = []
        for (nx, ny), r in zip(normals, inradii):
            a, b = nx, ny
            c = r  # shift from center by inradius
            lines.append((a, b, c))

        # Compute intersections of consecutive lines
        vertices = []
        for i in range(n_sides):
            a1, b1, c1 = lines[i]
            a2, b2, c2 = lines[(i + 1) % n_sides]

            det = a1 * b2 - a2 * b1
            if abs(det) < 1e-10:
                raise ValueError("Consecutive sides are parallel — invalid inradii/angles.")

            x = (c1 * b2 - c2 * b1) / det
            y = (a1 * c2 - a2 * c1) / det
            vertices.append((x, y))

        return cls(vertices)
    
    @classmethod
    def from_circumradii(cls,circumradii):
        
        vertices = []
        angles = np.arange(0,2*pi,pi/3)
        for circumradius, angle in zip(circumradii,angles):
            radius_on_y_axis = np.array((0,1))*circumradius
            rot_matrix = np.array(((cos(angle),-sin(angle)),(sin(angle),cos(angle))))
            vertex = np.matmul(rot_matrix,radius_on_y_axis)
            vertices.append(vertex)
        
        return cls(vertices)
    
class Pentagon(BasePolygon):
    def __init__(self, vertices):
        #checks that vertices meets the min requirements of a hexagon
        if len(vertices) != 5:
            raise ValueError("Pentagon must exactly 5 vertices.")
            
        #assign vertices, type of polygon, and computes side_lengths, and internal angles of polygon
        super().__init__(vertices, 'Pentagon')
    
    @classmethod
    def from_dimensions(cls,
                        width = [(1+sqrt(5))/4, (1+sqrt(5))/4],
                        height = [sqrt(5+sqrt(5))/2, (1+sqrt(5))/4],
                        side_length = 1):
        """
        Creates a flat-topped hexagon from width, height, and side_length

        """
        w1 = width[0]
        w2 = width[1]
        h1 = height[0]
        h2 = height[1]
        sl = side_length / 2
        
        vertices = [
                (-sl,-h1),
                (sl,-h1),
                (w2,0),
                (0,h2),
                (-w1,0)
            ]
        
        #calls __init__() with the wrapped vertices
        return cls(vertices)
    
    @classmethod
    def from_inradius(cls,inradius):
        """
        Creates a regular pentagon from the defined inradius of the geoemtry
        """
        # Number of sides and angle step
        n = 5
        angle_step = 2 * np.pi / n

        # Convert inradius to circumradius
        R = inradius / np.cos(np.pi / n)

        # Align the bottom edge to be horizontal (flat on x-axis)
        # Rotate so that one edge lies flat: shift angle by -π/2 - π/n
        start_angle = -np.pi / 2 - np.pi / n

        vertices = []
        for i in range(n):
            theta = start_angle + i * angle_step
            x = R * np.cos(theta)
            y = R * np.sin(theta)
            vertices.append((x, y))

        return cls(vertices)
    
    @classmethod
    def from_inradii(cls,inradii):
        """
        Construct a convex pentagon from given inradii (distances from incenter to each side).
        Assumes equiangular pentagon (sides are separated by 72°).
        
        Parameters:
            inradii (list of float): Five inradii.
            center (tuple): Incenter coordinates (x, y).
            start_angle (float): Orientation of the first side normal (radians).
    
        Returns:
            list of (x, y): Vertices of the pentagon in order.
            """
        if len(inradii) != 5:
            raise ValueError("Need exactly 5 inradii for a pentagon.")

        n_sides = 5
        angle_step = 2 * math.pi / n_sides

        # Compute outward normals
        normals = [(math.cos(i * angle_step),
                    math.sin(i * angle_step)) for i in range(n_sides)]

        # Each side line in form: a*x + b*y = c
        lines = []
        for (nx, ny), r in zip(normals, inradii):
            a, b = nx, ny
            c = r  # shift from center by inradius
            lines.append((a, b, c))

        # Compute intersections of consecutive lines
        vertices = []
        for i in range(n_sides):
            a1, b1, c1 = lines[i]
            a2, b2, c2 = lines[(i + 1) % n_sides]

            det = a1 * b2 - a2 * b1
            if abs(det) < 1e-10:
                raise ValueError("Consecutive sides are parallel — invalid inradii/angles.")

            x = (c1 * b2 - c2 * b1) / det
            y = (a1 * c2 - a2 * c1) / det
            vertices.append((x, y))

        return cls(vertices)
    
    @classmethod
    def from_circumradii(cls,circumradii):
        
        vertices = []
        angles = np.arange(0,2*pi,72*pi/180)
        for circumradius, angle in zip(circumradii,angles):
            radius_on_y_axis = np.array((0,1))*circumradius
            rot_matrix = np.array(((cos(angle),-sin(angle)),(sin(angle),cos(angle))))
            vertex = np.matmul(rot_matrix,radius_on_y_axis)
            vertices.append(vertex)
        
        return cls(vertices)

class Quadrilateral(BasePolygon):
    #use the class methods which wrap init in simpler parameters for ease of use
    def __init__(self, vertices):

        #checks that the parameters meet the min requirements of a quadrilateral
        if len(vertices) != 4:
            raise ValueError("Quadrilateral must have exactly 4 vertices.")
         
        #assign vertices, type of polygon, and computes side_lengths, and internal angles of polygon
        super().__init__(vertices, 'Quadrilateral')
            
    @classmethod
    def from_diagonals(cls, diagonals=[1,1,1,1]):
        """
        Creates a rotated quadrilateral with diagonal_1 = diagonals[0] + diagonals[1]
        and diagonal_2 = diagonals[2] + diagonals[3]

        """
        d1 = diagonals[0]
        d2 = diagonals[1]
        d3 = diagonals[2]
        d4 = diagonals[3]
        
        vertices = [
                (0,-d1),
                (d3,0),
                (0,d2),
                (-d4,0)
            ]
        
        #calls __init__() with the wrapped vertices
        return cls(vertices)
    
    @classmethod
    def from_sidelengths(cls, widths=[1,1], heights=[1,1]):
        w1 = widths[0]
        w2 = widths[1]
        h1 = heights[0]
        h2 = heights[1]
        
        vertices = [
                (-w1,-h1),
                (w1,-h1),
                (w2,h2),
                (-w2,h2)
            ]
        return cls(vertices)
    
    @classmethod
    def from_dimensions(cls, width=[1,1], height=[1,1]):
        """
        Creates a rotated quadrilateral with width = width[0] + width[1]
        and height = height[0] + height[1]
        """
        w1 = width[0]
        w2 = width[1]
        h1 = height[0]
        h2 = height[1]
        
        vertices = np.array(
            [(-w1,-h1),
             (w2,-h1),
             (w2,h2),
             (-w1,h2)]
            )
        
        theta = np.deg2rad(45)
        rotation_matrix = np.array([
            [np.cos(theta), -np.sin(theta)],
            [np.sin(theta),  np.cos(theta)]
        ])
        rotated = vertices @ rotation_matrix.T
        return cls(rotated)

#%% Polygon Measurement Functions

def all_sides_equal(side_lengths, tol=1e-8):
    arr = np.array(side_lengths)
    return np.all(np.abs(arr - arr[0]) < tol)

def polygon_from_vertices(vertices):
    """
    Given a list of 2D vertices [(x0, y0), (x1, y1), ..., (xn, yn)],
    returns:
    - side_lengths: list of side lengths
    - angles_deg: list of internal angles in degrees
    Skips consecutive duplicate vertices.
    """
    # Remove consecutive duplicates
    cleaned_vertices = []
    for v in vertices:
        if not cleaned_vertices or not np.allclose(v, cleaned_vertices[-1]):
            cleaned_vertices.append(v)

    # Ensure the polygon is still valid
    if len(cleaned_vertices) < 3:
        raise ValueError("Polygon must have at least 3 distinct vertices.")

    n = len(cleaned_vertices)
    side_lengths = []
    angles_deg = []

    for i in range(n):
        p0 = cleaned_vertices[i - 1]
        p1 = cleaned_vertices[i]
        p2 = cleaned_vertices[(i + 1) % n]

        # ---- Side length (p1 to p2)
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        length = math.hypot(dx, dy)
        side_lengths.append(length)

        # ---- Internal angle at p1 between vectors (p0->p1) and (p1->p2)
        v1 = (p0[0] - p1[0], p0[1] - p1[1])
        v2 = (p2[0] - p1[0], p2[1] - p1[1])

        norm1 = math.hypot(*v1)
        norm2 = math.hypot(*v2)

        # Guard against zero-length vectors
        if norm1 == 0 or norm2 == 0:
            angles_deg.append(0)
            continue

        dot = v1[0]*v2[0] + v1[1]*v2[1]
        cos_theta = max(min(dot / (norm1 * norm2), 1), -1)
        angle_rad = math.acos(cos_theta)
        angle_deg = math.degrees(angle_rad)
        angles_deg.append(angle_deg)
    angles_deg = np.array(angles_deg)
    
    return side_lengths, angles_deg

#%% Polygon Plotting Function
def plot_polygon(vertices, color='lightblue', edgecolor='black', show_vertices=True,
                 title=None, ax=None, label=None):
    """Plot a polygon on the given axis (or create a new one)."""
    # Create figure and axis only if none is provided
    if ax is None:
        fig, ax = plt.subplots()
        new_fig = True
    else:
        new_fig = False

    patch = MplPolygon(vertices, closed=True, facecolor=color, edgecolor=edgecolor, label=label)
    ax.add_patch(patch)

    if show_vertices:
        xs, ys = zip(*vertices)
        ax.plot(xs, ys, 'o', color='red', markersize=4)

    if title and new_fig:
        ax.set_title(title)

    ax.set_aspect('equal')
    ax.autoscale()
    ax.grid(True)

    # Only call plt.show() if we created the figure ourselves
    if new_fig:
        plt.show()

    return ax  # Always return the axis for further use

#%% Testing space
if __name__ == "__main__":
    plt.close('all')
    
    #generic geometry testing
    regular_hexagon = Hexagon.from_dimensions()
    regular_hexagon.plot()
    print(regular_hexagon.side_lengths)
    print(regular_hexagon.angles_deg)
    
    inradii = np.array((1,1.6,1,1,1.6))
    inradii_pentagon = Pentagon.from_inradii(inradii)
    inradii_pentagon.plot()
    print(inradii_pentagon.angles_deg)
    
    inradii = np.array((1,1,1,1,1,1))
    inradii_hexagon = Hexagon.from_inradii(inradii)
    inradii_hexagon.plot()
    print(inradii_hexagon.angles_deg)
    
    inradii = np.array((1.5,1,1,1,1,1))
    inradii_hexagon = Hexagon.from_inradii(inradii)
    inradii_hexagon.plot()
    print(inradii_hexagon.angles_deg)
    
    regular_pentagon = Pentagon.from_dimensions()
    regular_pentagon.plot()
    print(regular_pentagon.side_lengths)
    print(regular_pentagon.angles_deg)
    
    irregular_hexagon = Hexagon.from_dimensions(width=[1,0.5])
    irregular_hexagon.plot()
    print(irregular_hexagon.side_lengths)
    print(irregular_hexagon.angles_deg)
    
    trapezoid = Hexagon.from_dimensions(height=[0,sqrt(3)/2])
    trapezoid.plot()
    print(trapezoid.side_lengths)
    print(trapezoid.angles_deg)
    
    diamond = Quadrilateral.from_dimensions()
    diamond.plot()
    print(diamond.side_lengths)
    print(diamond.angles_deg)
    
    #ArrayElement testing
    hexagon_element = ArrayElement(regular_hexagon,center=(5,0), rotation_deg=0)
    hexagon_element_2 = hexagon_element.copy_with_transform(center=(0,5), rotation_deg=-45)
    hexagon_element_3 = hexagon_element.copy_with_transform(center= (0,-5), rotation_deg = -105).resize(0.5)
    hexagon_element_4 = hexagon_element.copy_with_transform(center=(0,0),rotation_deg = 45).resize(-0.5)
    
    #GeometryArray testing
    array = GeometryArray(elements=[hexagon_element,hexagon_element_2,hexagon_element_3,hexagon_element_4])
    array.plot()
    
    print(array.to_gdspy())
    print(array.to_shapely())
    
    #VCSELGenerator testing
    #build Dalir Mesa and erode it
    diamond = Quadrilateral.from_dimensions(width=[7.5,7.5],height=[7.5,7.5])
    diamond.plot()
    #check to make sure side lengths equal 2*6 (lateral_growth) + 3 (aperture_size)
    print(diamond.side_lengths)
    dalir_element_1 = ArrayElement(diamond)
    dalir_element_2 = dalir_element_1.copy_with_transform(center=(7.757,0))
    dalir_geometries = GeometryArray(elements=[dalir_element_1,dalir_element_2])
    
    dalir_device = VCSELGenerator([dalir_geometries], lateral_growth = 6,
                                  implant_width = 22, implant_length = 2,
                                  implant_padding = 3)
    dalir_device.generate_all()
    dalir_device.plot(show_aperture=True,
                      show_implant=True,
                      show_contact_partitions=True,
                      show_contact_region=True)
    
    #build 45 angled mesa structure
    lateral_growth = 5
    aperture_diameter = 3
    perturbation = 0
    edge_cavity = Pentagon.from_inradius(lateral_growth + aperture_diameter/2)
    left_edge = ArrayElement(edge_cavity,center=(lateral_growth+aperture_diameter/2,0),
                             rotation_deg=72+22.5)
    right_edge = ArrayElement(edge_cavity,center=(-lateral_growth-aperture_diameter/2,0),
                              rotation_deg=-72-22.5)
    
    center_cavity = Hexagon.from_dimensions(width=[lateral_growth+aperture_diameter,
                                                   lateral_growth+aperture_diameter],
                                            height=[lateral_growth+aperture_diameter/2,
                                                    lateral_growth+aperture_diameter/2+perturbation],
                                            side_length=[lateral_growth,lateral_growth+aperture_diameter])
    centerElement = ArrayElement(center_cavity,center = (0,aperture_diameter*3/4))
    
    angled_array = GeometryArray([left_edge,centerElement,right_edge])
    angled_array.plot()
    
    angled_bowtie_generator = VCSELGenerator([angled_array],
                                             lateral_growth = lateral_growth,
                                             implant_width=22,
                                             implant_length=2,
                                             contact_padding=1,
                                             element_zone_padding=0)
    angled_bowtie_generator.generate_all()
    angled_bowtie_generator.plot(show_aperture=True,
                                 show_implant=False,
                                 show_implant_inv=True,
                                 show_contact_partitions=True,
                                 show_contact_region=True)